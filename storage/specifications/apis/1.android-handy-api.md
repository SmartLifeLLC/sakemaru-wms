# Android出荷作業端末向け API 仕様（概要版 / 既存WMSテーブル準拠）

---

## 1. 目的 / 対象範囲

* 倉庫出荷作業（ピッキング）に必要な **ログイン**、**倉庫選択**、**タスク取得**、**ピック実績登録**、**タスク完了**、**ログアウト
  ** を提供。
* **認証子**は `wms_pickers.code` とパスワード（暗号化保存）を使用。メールアドレスは使用しない。
* L5:swaggerを利用しAPI ドキュメントを作成する。
* url のprefixは /api

---

## 2. 関連テーブル（抜粋）

### 2.1 wms_pickers

* `id, code(Unique), name, password(hashed), default_warehouse_id, is_active, timestamps`

### 2.2 wms_picking_tasks

*
`id, wave_id, wms_picking_area_id, warehouse_id, warehouse_code, delivery_course_id, delivery_course_code, shipment_date, trade_id, status(PENDING|PICKING|COMPLETED), task_type(WAVE|REALLOCATION), picker_id, started_at, completed_at, timestamps`
* 代表インデックス: `(wave_id, wms_picking_area_id, status)`, `(wave_id, status)`, `(warehouse_code)`, `(delivery_course_code)`
* **変更点**:
  * `earning_id` 削除（伝票IDは `wms_picking_item_results` に移動）
  * `delivery_course_id`, `delivery_course_code` 追加（タスクを配送コース別にグループ化）
  * `warehouse_code` 追加（検索・フィルタリング用の非正規化カラム）
  * `shipment_date` 追加（出荷予定日）
  * `status` から `SHORTAGE` 削除（欠品追跡は item_results の `has_shortage` フラグで管理）

### 2.3 wms_picking_item_results

*
`id, picking_task_id, trade_item_id, item_id, real_stock_id, location_id, wms_picking_area_id, walking_order, ordered_qty, ordered_qty_type, planned_qty, planned_qty_type, picked_qty, picked_qty_type, shortage_qty, has_physical_shortage(generated), status(PICKING|COMPLETED|SHORTAGE), picked_at, picker_id, timestamps`
* 代表インデックス: `(wms_picking_area_id, walking_order, item_id)`, `(picking_task_id)`

> 並び順: 端末表示は **`wms_picking_area_id, walking_order, item_id`**
> を優先（歩行順最適化）。ピッキングエリア（常温/冷蔵/冷凍/フォークリフト）ごとにタスクが分割されます。

---

## 3. 認証 / セッション

* 認証方式: `POST /auth/login` でトークン発行（形式は実装側の標準: JWT など）。
* セッション終了: `POST /auth/logout`。
* 監査: ログイン/ログアウト時に `picker_id`, `device_id`, `timestamp` をログ記録。

### 3.1 エンドポイント

1. **ログイン** `POST /auth/login`

* 入力: `{ code, password, device_id? }`
* 成功: `{ token, picker: { id, code, name, default_warehouse_id } }`
* 失敗: 401（コード/パスワード不一致、`is_active=0`）

2. **ログアウト** `POST /auth/logout`

* 成功: 204

3. **自分情報** `GET /me`

* 成功: `{ id, code, name, default_warehouse_id }`

---

## 4. マスタ取得

> 既存の倉庫テーブルを利用（本仕様ではスキーマ省略）。

4. **倉庫一覧** `GET /warehouses`

* 出力: `[{ id, code, name }]`

5. **ピッキングエリア一覧** `GET /picking-areas?warehouse_id=...`

* 出力: `[{ id, code, name, warehouse_id }]`

> ※名称・フィールドは既存マスタに合わせる。端末は **`warehouse_id` を必須** とする前提。

---

## 5. ピッキングタスク

### 5.1 一覧取得

6. **タスク一覧** `GET /picking/tasks`

* クエリ: `warehouse_id(required)`, `picker_id`, 'picking_area_id'

* 戻り:配送コース別のピッキングリスト
    * 同じ配送コースには複数伝票のピッキングリストが来る。
    * 商品のピッキング順番はサーバで整理される。（商品ピッキングが最適化された順番でくる。）
    *
        * 同じ配送コース(course(333):テストコース,)で 伝票１に商品１、２、３、伝票２に商品２、４、５があり、 商品のピッキング最適順番が（２、３、１、５、４）で
          商品１、２、３、４が同じpicking area(123):'PA-1'だった場合、
          結果としては['data'=[1=>['course'=>['code'=>'333','name'=>'テストコース']
          ,'picking_area'=>['code'=>'123','name'=>'PA-1'],'wave'=>['wms_picking_task_id'=>'xxxx'','wms_wave_id'=>'xxxx']
    * picking_list'=>[
      1=>['item_id'=>2,'item_name'=>'name2','planned_qty_type'=>'PIECE','planned_qty'=>'1','picked_qty'=>'0','walking_order'=>1,'wms_picking_item_result_id'=>xxx,'slip_number'=>1],
    *                    2=>['item_id'=>2,'item_name'=>'name2','planned_qty_type'=>'PIECE','planned_qty'=>'3','picked_qty'=>'0','walking_order'=>2,'wms_picking_item_result_id'=>xxx,'slip_number'=>2],
        *                  3=>['item_id'=>3,'item_name'=>'name3','planned_qty_type'=>'PIECE','planned_qty'=>'3','picked_qty'=>'0','walking_order'=>3,'wms_picking_item_result_id'=>xxx,'slip_number'=>1],
        *                  4=>['item_id'=>1,'item_name'=>'name1','planned_qty_type'=>'CASE','planned_qty'=>'1','picked_qty'=>'0','walking_order'=>4,'wms_picking_item_result_id'=>xxx,'slip_number'=>1],
        *                  4=>['item_id'=>5,'item_name'=>'name1','planned_qty_type'=>'PIECE','planned_qty'=>'5','picked_qty'=>'0','walking_order'=>4,'wms_picking_item_result_id'=>xxx,'slip_number'=>2],
        *                  4=>['item_id'=>4,'item_name'=>'name1','planned_qty_type'=>'PIECE','planned_qty'=>'5','picked_qty'=>'0','walking_order'=>4,'wms_picking_item_result_id'=>xxx,'slip_number'=>2],
    * ],
    *
    * ]]

-- 同じアイテムでも伝票別のピッキングになることが必須

7. **開始** `POST /picking/tasks/{wms_picking_task_id}/start`
   該当wms_picking_task_idのwms_picking_tasksテーブルの状態をPICKINGに変更するAPI
   
8. **ピッキング**　`POST /picking/tasks/{wms_picking_item_result_id}/update`
該当する商品のぴっきんぐけっか（数字）を送る。パラメターはピッキングした数量wms_picking_item_resultsを更新。wms_real_stocksも更新。引き当てのタイミング（wave生成時に）wms_real_stocksも生成されている必要がある。
picking時には在庫数が-になるような状態が発生しても許可する（倉庫に在庫がもっとあったことなので。
9**完了** `POST /picking/tasks/{wms_picking_task_id}/complete`
    該当するピッキングの完了を送信.wms_picking_tasksの状態をwms_picking_item_resultsの紐づくレコードでSHORTAGEの状態があればSHORTAGE'なければ'COMPLETEDに変更。完了時にwms_real_stocksのレコードをreal_stocks, wms_real_stockを

10. 
* 既定: **全行 `status=COMPLETED` で `COMPLETED`**。未達ありは `SHORTAGE` で完了可（業務設定で可否制御）。
* 作用: `completed_at=now`, `status` を最終判定。
* 失敗: 422（未処理行ありで `allow_short=false` 等）

### 5.4 行ピック（数量登録）

11. **ピック登録** `POST /picking/tasks/{id}/items/{item_result_id}/pick`

* 入力: `{ picked_qty(+), picked_qty_type?, location_id?, real_stock_id? }`
* 作用: `picked_qty` を加算 or 置換（実装ポリシー選択）。`picked_at=now`, `picker_id=me`。
* 行状態自動更新:

    * `picked_qty == planned_qty` → `status=COMPLETED`, `shortage_qty=0`
    * `picked_qty < planned_qty` → `status=PICKING`, `shortage_qty = planned_qty - picked_qty`
    * `picked_qty > planned_qty` → 422（過剰）※許容時は調整ロジックを別途
* タスク状態自動更新:

    * 1 行でも `shortage_qty>0` が残る → `wms_picking_tasks.status = SHORTAGE`（暫定）
    * 全行 `COMPLETED` → `wms_picking_tasks.status = COMPLETED`
* 失敗: 409（在庫/予約の競合）, 422（数量/型不正）

12. **直前取り消し（任意）** `POST /picking/tasks/{id}/items/{item_result_id}/undo`

* 作用: 直近登録分の数量を巻き戻し（監査記録必須）。

---

## 6. バリデーション / ルール

* ログイン: `code` 必須、
* タスク取得: `warehouse_id` 必須。
* ピック登録:

    * `picked_qty > 0`（整数）
    * `picked_qty_type` は `planned_qty_type` に合致（相違時の換算はサーバ側定義がない限り不可）
    * 同時更新対策: 行にバージョン/ETag を付与し、競合時 409。
* 完了: 行に `PICKING` が残存する場合は 422（allow_short が真であれば `SHORTAGE` 完了可）。

---

## 7. エラーレスポンス（例）

基本的にはエラーもresponseを返す。

* `400` バリデーション: `{ message, errors: { field: [msg] } }`
* `401` 未認証 / 無効トークン
* `403` 権限不足
* `404` 未検出
* `409` 競合（割当済/並行更新/在庫予約の衝突）
* `422` 業務ルール違反（過剰/型不一致/未達完了禁止）
* `500` サーバエラー

---

